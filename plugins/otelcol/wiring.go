// Package otelcol provides a plugin to generate and include an OpenTelemetry collector instance in a Blueprint application.
//
// # Wiring Spec Usage
//
// To instantiate an OpenTelemetry collector container with a backend:
//
//	jaeger := jaeger.Collector(spec, "jaeger")
//	collector := otelcol.Collector(spec, "otelcol", jaeger)
//
// The returned collectorName must be used as an argument to the `opentelemetry.Instrument(spec, serviceName, collector)` to ensure the spans generated by instrumented services are correctly exported to the instantiated server.
//
// # Artifacts Generated
//
//  1. The package provides an OpenTelemetry collector container that provides the server-side implementation of the OpenTelemetry collector.
//  2. Instantiates a [OTCollectorTracer] instance for configuring the opentelemetry runtime libraries to export all generated traces to the OpenTelemetry collector.
//  3. Configures the collector to forward traces to the specified backend (e.g., Jaeger, Zipkin).
//
// [OTCollectorTracer]: https://github.com/Blueprint-uServices/blueprint/tree/main/runtime/plugins/otelcol
package otelcol

import (
	"github.com/blueprint-uservices/blueprint/blueprint/pkg/coreplugins/address"
	"github.com/blueprint-uservices/blueprint/blueprint/pkg/coreplugins/pointer"
	"github.com/blueprint-uservices/blueprint/blueprint/pkg/ir"
	"github.com/blueprint-uservices/blueprint/blueprint/pkg/wiring"
)

// [Collector] can be used by the wiring spec to add and instantiate an OpenTelemetry collector docker container named `collectorName` that uses the latest OpenTelemetry collector container
// and the clients needed by the generated application to communicate with the server.
//
// The returned collectorName must be used as an argument to the opentelemetry.Instrument(spec, serviceName, `collectorName`) to ensure the spans generated by instrumented services are correctly exported to the instantiated server.
//
// # Wiring Spec Usage
//
//	jaeger := jaeger.Collector(spec, "jaeger")
//	collector := otelcol.Collector(spec, "otelcol", jaeger)
//
//	// Or with specific exporter type:
//	collector := otelcol.Collector(spec, "otelcol", jaeger, "jaeger")
//	collector := otelcol.Collector(spec, "otelcol", zipkin, "zipkin")
func Collector(spec wiring.WiringSpec, collectorName string, backendRef string, exporterType ...string) string {
	// The nodes that we are defining
	collectorAddr := collectorName + ".addr"
	collectorCtr := collectorName + ".ctr"
	collectorClient := collectorName + ".client"

	// Define the OpenTelemetry collector container
	spec.Define(collectorCtr, &OTCollectorContainer{}, func(ns wiring.Namespace) (ir.IRNode, error) {
		// Resolve the backend address generically without hardcoding types
		backendDialName := backendRef + ".dial_addr"

		// Get the dial config directly from the namespace
		var backendDialConfig *address.DialConfig
		if err := ns.Get(backendDialName, &backendDialConfig); err != nil {
			return nil, err
		}

		otelcol, err := newOTCollectorContainer(collectorCtr, backendDialConfig, exporterType...)
		if err != nil {
			return nil, err
		}

		err = address.Bind[*OTCollectorContainer](ns, collectorAddr, otelcol, &otelcol.BindAddr)
		return otelcol, err
	})

	// Create a pointer to the OpenTelemetry collector container
	ptr := pointer.CreatePointer[*OTCollectorClient](spec, collectorName, collectorCtr)

	// Define the address that points to the OpenTelemetry collector container
	address.Define[*OTCollectorContainer](spec, collectorAddr, collectorCtr)

	// Add the address to the pointer
	ptr.AddAddrModifier(spec, collectorAddr)

	// Define the OpenTelemetry collector client and add it to the client side of the pointer
	clientNext := ptr.AddSrcModifier(spec, collectorClient)
	spec.Define(collectorClient, &OTCollectorClient{}, func(ns wiring.Namespace) (ir.IRNode, error) {
		addr, err := address.Dial[*OTCollectorContainer](ns, clientNext)
		if err != nil {
			return nil, err
		}

		return newOTCollectorClient(collectorClient, addr.Dial)
	})

	// Return the pointer; anybody who wants to access the OpenTelemetry collector instance should do so through the pointer
	return collectorName
}
