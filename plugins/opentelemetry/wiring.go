// Package OpenTelemetry provides a Blueprint plugin for instrumenting services and collecting OpenTelemetry traces. The plugin provides APIs to be used in the wiring specification for the following:
//
//  1. to wrap the service with an OpenTelemetry wrapper to generate OT compatible traces by starting and stopping client spans for remote calls between services and correctly propagating context between services. The traces are then exported to a collector client such as [jaeger] or [zipkin].
//  2. to install an opentelemetry trace-based event logger for a go process. The logger adds all the logs as events to the current active span. If no active span exists, then no events are logged.
//
// Once the application is instrumented with these plugins, traces will be generated by the instrumented services, and collected centrally at the trace collector.
//
// # Wiring Usage
//
// To instrument services with opentelemetry instrumentation:
//
//	opentelemetry.Instrument(spec, "my_service", "collector_name")
//
// Calling [Instrument] will generate client and server side wrappers responsible for starting and stopping spans as well as correctly propagating the context across service boundaries.
//
// To redirect a process's logging statements to opentelemetry generated spans:
//
//	opentelemetry.Logger(spec, "my_process")
//
// Calling [Logger] will redirect all logging statements generated by the process to opentelemetry where the log statements will be converted into opentelemetry Events and added to the list of events for the current active span.
//
// In order to generate complete end-to-end traces of the application, all services of the application need to be instrumented with OpenTelemetry.
// If the plugin is only applied to a subset of services, the application will run, but the traces produced won't be end-to-end and won't be useful.
// The plugin does not support instrumenting clients for backends such as databases, caches, queues, etc. If needed, please consider submitting a PR or contacting the maintainers via google groups or on slack.
//
// # Artifacts Generated
//
//  1. The package generates client and server side wrappers for instrumented services that contain opentelemetry instrumentation (context propagation, creation of spans). The generated clients handle context propagation correctly on both the server and client sides. The implementation of the logger is located at [runtime/plugins/opentelemetry] and if the opentelemetry logger is installed for a process then this logger is used.
//
// Example usage (for complete instrumentation):
//
// # Wiring Example
//
//	func applyOTelOptions() {
//		jaeger.Container(spec, "jaeger")
//		for _, service := range serviceNames {
//			opentelemetry.Instrument(spec, service)
//		}
//		for _, proc := range processNames {
//			opentelemetry.Logger(spec, proc)
//		}
//	}
//
// See the [ot_logger] wiring spec for the Leaf application for a complete example
//
// # Accessing Traces
//
// The traces are generated and sent to the configured ([zipkin] or [jaeger]) collector. Each collector exposes a web UI which can be used to access end-to-end traces. For Zipkin, the UI is hosted at port 9411 by default and for Jaeger, the UI is hosted at port 16686 by default.
//
// [ot_logger]: https://github.com/Blueprint-uServices/blueprint/tree/main/examples/leaf/wiring/specs/custom_logger.go
// [zipkin]: https://github.com/Blueprint-uServices/blueprint/tree/main/plugins/zipkin
// [jaeger]: https://github.com/Blueprint-uServices/blueprint/tree/main/plugins/jaeger
package opentelemetry

import (
	"fmt"

	"github.com/blueprint-uservices/blueprint/blueprint/pkg/ir"
	"github.com/blueprint-uservices/blueprint/blueprint/pkg/wiring"
	"github.com/blueprint-uservices/blueprint/plugins/goproc"
)

// CollectorInterface defines the interface that all collectors must implement
type CollectorInterface interface {
	ir.IRNode
	GetEndpoint() string
}

// Instrument adds OpenTelemetry instrumentation to a service.
// It wraps both client and server sides with OpenTelemetry instrumentation.
func Instrument(spec wiring.WiringSpec, serviceName string, collectorName string) string {
	// Define the client wrapper
	clientWrapper := fmt.Sprintf("%s.client.ot", serviceName)
	spec.Define(clientWrapper, &OpenTelemetryClientWrapper{}, func(ns wiring.Namespace) (ir.IRNode, error) {
		var service ir.IRNode
		if err := ns.Get(serviceName, &service); err != nil {
			return nil, err
		}

		return &OpenTelemetryClientWrapper{
			ServiceName:   serviceName,
			ServiceClient: service,
		}, nil
	})

	// Define the server wrapper
	serverWrapper := fmt.Sprintf("%s.server.ot", serviceName)
	spec.Define(serverWrapper, &OpenTelemetryServerWrapper{}, func(ns wiring.Namespace) (ir.IRNode, error) {
		var service ir.IRNode
		if err := ns.Get(serviceName, &service); err != nil {
			return nil, err
		}

		return &OpenTelemetryServerWrapper{
			ServiceName:   serviceName,
			ServiceServer: service,
		}, nil
	})

	// Return the name of the instrumented service
	return serviceName
}

// [Logger] can be used by wiring specs to install a process-level ot logger for process `processName` to be used in tandem with an OT Tracer. Replaces the existing logger installed for the process.
//
// Logs are added as `ot.Events` to the current span and will be added as events to the current span and won't appear in stdout.
//
// If no current span is being recorded, then no events will be generated. Use `Instrument` to ensure that all services in a process are instrumented with OpenTelemetry and are creating active spans.
//
// # Wiring Spec Usage:
//
//	opentelemetry.Logger(spec, "my_process")
func Logger(spec wiring.WiringSpec, processName string) string {
	logger := processName + "_ottrace_logger"
	spec.Define(logger, &OTTraceLogger{}, func(ns wiring.Namespace) (ir.IRNode, error) {
		return newOTTraceLogger(logger)
	})
	goproc.SetLogger(spec, processName, logger)
	return logger
}
