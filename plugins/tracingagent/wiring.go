// Package tracingagent provides a plugin to generate and include a tracing agent instance in a Blueprint application.
//
// # Wiring Spec Usage
//
// To instantiate a tracing agent container:
//
//	agent := tracingagent.Agent(spec, "tracing_agent")
//
// The returned agentName must be used as an argument to the `opentelemetry.Instrument(spec, serviceName, agent)` to ensure the spans generated by instrumented services are correctly exported to the instantiated agent.
//
// # Artifacts Generated
//
//  1. The package provides a tracing agent container that provides the server-side implementation of the tracing agent.
//  2. Instantiates a [TracingAgentService] instance for configuring the opentelemetry runtime libraries to export all generated traces to the tracing agent.
//
// [TracingAgentService]: https://github.com/Blueprint-uServices/blueprint/tree/main/runtime/plugins/tracingagent
package tracingagent

import (
	"github.com/blueprint-uservices/blueprint/blueprint/pkg/coreplugins/pointer"
	"github.com/blueprint-uservices/blueprint/blueprint/pkg/ir"
	"github.com/blueprint-uservices/blueprint/blueprint/pkg/wiring"
)

// Agent can be used by the wiring spec to add and instantiate a tracing agent container named `tracingAgentName` that provides
// the server-side implementation of the tracing agent and the clients needed by the generated application to communicate with the server.
//
// The returned tracingAgentName must be used as an argument to the opentelemetry.Instrument(spec, serviceName, `tracingAgentName`) to ensure the spans generated by instrumented services are correctly exported to the instantiated server.
//
// # Wiring Spec Usage
//
//	tracingagent.Agent(spec, "tracing_agent")
// func Agent(spec wiring.WiringSpec, tracingAgentName string) string {
// 	// The nodes that we are defining
// 	tracingAgentAddr := tracingAgentName + ".addr"
// 	tracingAgentCtr := tracingAgentName + ".ctr"
// 	tracingAgentClient := tracingAgentName + ".client"

// 	// Define the Zipkin collector container
// 	spec.Define(tracingAgentCtr, &TracingAgentServiceNode{}, func(ns wiring.Namespace) (ir.IRNode, error) {
// 		tracingAgent, err := newTracingAgentServiceNode(tracingAgentCtr)
// 		if err != nil {
// 			return nil, err
// 		}

// 		err = address.Bind[*TracingAgentServiceNode](ns, tracingAgentAddr, tracingAgent, &tracingAgent.BindAddr)
// 		return tracingAgent, err
// 	})

// 	// Create a pointer to the Zipkin collector container
// 	ptr := pointer.CreatePointer[*TracingAgentClient](spec, tracingAgentName, tracingAgentCtr)

// 	// Define the address that points to the Zipkin collector container
// 	address.Define[*TracingAgentServiceNode](spec, tracingAgentAddr, tracingAgentCtr)

// 	// Add the address to the pointer
// 	ptr.AddAddrModifier(spec, tracingAgentAddr)

// 	// Define the Zipkin collector client and add it to the client side of the pointer
// 	clientNext := ptr.AddSrcModifier(spec, tracingAgentClient)
// 	spec.Define(tracingAgentClient, &TracingAgentClient{}, func(ns wiring.Namespace) (ir.IRNode, error) {
// 		addr, err := address.Dial[*TracingAgentServiceNode](ns, clientNext)
// 		if err != nil {
// 			return nil, err
// 		}

// 		return newTracingAgentClient(tracingAgentName, addr.Dial)
// 	})

// 	// Return the pointer; anybody who wants to access the Zipkin collector instance should do so through the pointer
// 	return tracingAgentName
// }

func Agent(spec wiring.WiringSpec, tracingAgentName string) string {
	// The nodes that we are defining
	// tracingAgentAddr := tracingAgentName + ".addr"
	tracingAgentCtr := tracingAgentName + ".ctr"
	tracingAgentClient := tracingAgentName + ".client"

	// Define the tracing agent service node
	spec.Define(tracingAgentCtr, &TracingAgentServiceNode{}, func(ns wiring.Namespace) (ir.IRNode, error) {
		// tracingAgent, err := newTracingAgentServiceNode(tracingAgentCtr)
		return newTracingAgentServiceNode(tracingAgentCtr)
		// if err != nil {
		// 	return nil, err
		// }

		// err = address.Bind[*TracingAgentServiceNode](ns, tracingAgentAddr, tracingAgent, &tracingAgent.BindAddr)
		// return tracingAgent, err
	})

	// Create a pointer to the tracing agent service node
	ptr := pointer.CreatePointer[*TracingAgentClient](spec, tracingAgentName, tracingAgentCtr)

	// // Define the address that points to the tracing agent service node
	// address.Define[*TracingAgentServiceNode](spec, tracingAgentAddr, tracingAgentCtr)

	// Add the address to the pointer
	// ptr.AddAddrModifier(spec, tracingAgentAddr)
	ptr.AddDstModifier(spec, tracingAgentCtr)

	// Add the client as a source modifier (so the pointer resolves to the client)
	clientNext := ptr.AddSrcModifier(spec, tracingAgentClient)

	// Define the tracing agent client node, linking directly to the service node
	spec.Define(tracingAgentClient, &TracingAgentClient{}, func(ns wiring.Namespace) (ir.IRNode, error) {
		// Get the actual tracing agent service node from the namespace
		var tracingAgentService ir.IRNode
		err := ns.Get(clientNext, &tracingAgentService)
		if err != nil {
			return nil, err
		}

		// // clientNext is used to maintain the pointer chain for containerization
		// _ = clientNext // keep for pointer chain compatibility

		return newTracingAgentClient(tracingAgentName, tracingAgentService)
	})

	// Return the pointer; anybody who wants to access the tracing agent instance should do so through the pointer
	return tracingAgentName
}
