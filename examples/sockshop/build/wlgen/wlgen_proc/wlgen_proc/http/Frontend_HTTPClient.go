// Blueprint: Auto-generated by the HTTP Plugin
package http

import (
	"io"
	"github.com/blueprint-uservices/blueprint/examples/sockshop/workflow/cart"
	"net/http"
	"encoding/json"
	"context"
	"net/url"
	"fmt"
	"errors"
	"github.com/blueprint-uservices/blueprint/examples/sockshop/workflow/user"
	"github.com/blueprint-uservices/blueprint/examples/sockshop/workflow/order"
	"github.com/blueprint-uservices/blueprint/examples/sockshop/workflow/catalogue"
)

type Frontend_HTTPClient struct {
	Client *http.Client
	ServerAddress string
}

func New_Frontend_HTTPClient(ctx context.Context, serverAddress string) (*Frontend_HTTPClient, error) {
	defaultRoundTripper := http.DefaultTransport
	defaultTransportPointer, ok := defaultRoundTripper.(*http.Transport)
	if !ok {
		return nil, errors.New("defaultRoundTripper not an *http.Transport")
	}
	defaultTransport := *defaultTransportPointer // dereference it to get a copy of the struct that the pointer points to
	defaultTransport.MaxIdleConns = 60000
	defaultTransport.MaxIdleConnsPerHost = 60000
	defaultTransport.MaxConnsPerHost = 10000
	client := &http.Client{
		Transport: &defaultTransport,
	}
	c := &Frontend_HTTPClient{}
	c.Client = client
	c.ServerAddress = "http://" + serverAddress
	return c, nil
}


func (client *Frontend_HTTPClient) AddItem(ctx context.Context, sessionID string, itemID string, traceCtx string) (ret0 string, err error) {
	vals := url.Values{}
	
	vals.Add("sessionID", sessionID)
	
	vals.Add("itemID", itemID)
	
	vals.Add("traceCtx", traceCtx)
	

	encoded_url, err := url.Parse(client.ServerAddress + "/AddItem")
	if err != nil {
		return
	}
	encoded_url.RawQuery = vals.Encode()

	resp, err := client.Client.Get(encoded_url.String())
	if err != nil {
		return
	}
	defer resp.Body.Close()
	statusOk := resp.StatusCode >= 200 && resp.StatusCode < 300
	if !statusOk {
		err = fmt.Errorf("StatusCode was %d", resp.StatusCode)
		return
	}
	response := struct {
		
		Ret0 string
		
	}{}
	resp_bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return
	}
	err = json.Unmarshal(resp_bytes, &response)
	if err != nil {
		return
	}
	
	ret0 = response.Ret0
	
	return
}

func (client *Frontend_HTTPClient) DeleteCart(ctx context.Context, sessionID string, traceCtx string) (err error) {
	vals := url.Values{}
	
	vals.Add("sessionID", sessionID)
	
	vals.Add("traceCtx", traceCtx)
	

	encoded_url, err := url.Parse(client.ServerAddress + "/DeleteCart")
	if err != nil {
		return
	}
	encoded_url.RawQuery = vals.Encode()

	resp, err := client.Client.Get(encoded_url.String())
	if err != nil {
		return
	}
	defer resp.Body.Close()
	statusOk := resp.StatusCode >= 200 && resp.StatusCode < 300
	if !statusOk {
		err = fmt.Errorf("StatusCode was %d", resp.StatusCode)
		return
	}
	response := struct {
		
	}{}
	resp_bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return
	}
	err = json.Unmarshal(resp_bytes, &response)
	if err != nil {
		return
	}
	
	return
}

func (client *Frontend_HTTPClient) GetAddress(ctx context.Context, addressID string, traceCtx string) (ret0 user.Address, err error) {
	vals := url.Values{}
	
	vals.Add("addressID", addressID)
	
	vals.Add("traceCtx", traceCtx)
	

	encoded_url, err := url.Parse(client.ServerAddress + "/GetAddress")
	if err != nil {
		return
	}
	encoded_url.RawQuery = vals.Encode()

	resp, err := client.Client.Get(encoded_url.String())
	if err != nil {
		return
	}
	defer resp.Body.Close()
	statusOk := resp.StatusCode >= 200 && resp.StatusCode < 300
	if !statusOk {
		err = fmt.Errorf("StatusCode was %d", resp.StatusCode)
		return
	}
	response := struct {
		
		Ret0 user.Address
		
	}{}
	resp_bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return
	}
	err = json.Unmarshal(resp_bytes, &response)
	if err != nil {
		return
	}
	
	ret0 = response.Ret0
	
	return
}

func (client *Frontend_HTTPClient) GetCard(ctx context.Context, cardID string, traceCtx string) (ret0 user.Card, err error) {
	vals := url.Values{}
	
	vals.Add("cardID", cardID)
	
	vals.Add("traceCtx", traceCtx)
	

	encoded_url, err := url.Parse(client.ServerAddress + "/GetCard")
	if err != nil {
		return
	}
	encoded_url.RawQuery = vals.Encode()

	resp, err := client.Client.Get(encoded_url.String())
	if err != nil {
		return
	}
	defer resp.Body.Close()
	statusOk := resp.StatusCode >= 200 && resp.StatusCode < 300
	if !statusOk {
		err = fmt.Errorf("StatusCode was %d", resp.StatusCode)
		return
	}
	response := struct {
		
		Ret0 user.Card
		
	}{}
	resp_bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return
	}
	err = json.Unmarshal(resp_bytes, &response)
	if err != nil {
		return
	}
	
	ret0 = response.Ret0
	
	return
}

func (client *Frontend_HTTPClient) GetCart(ctx context.Context, sessionID string, traceCtx string) (ret0 []cart.Item, err error) {
	vals := url.Values{}
	
	vals.Add("sessionID", sessionID)
	
	vals.Add("traceCtx", traceCtx)
	

	encoded_url, err := url.Parse(client.ServerAddress + "/GetCart")
	if err != nil {
		return
	}
	encoded_url.RawQuery = vals.Encode()

	resp, err := client.Client.Get(encoded_url.String())
	if err != nil {
		return
	}
	defer resp.Body.Close()
	statusOk := resp.StatusCode >= 200 && resp.StatusCode < 300
	if !statusOk {
		err = fmt.Errorf("StatusCode was %d", resp.StatusCode)
		return
	}
	response := struct {
		
		Ret0 []cart.Item
		
	}{}
	resp_bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return
	}
	err = json.Unmarshal(resp_bytes, &response)
	if err != nil {
		return
	}
	
	ret0 = response.Ret0
	
	return
}

func (client *Frontend_HTTPClient) GetOrder(ctx context.Context, orderID string, traceCtx string) (ret0 order.Order, err error) {
	vals := url.Values{}
	
	vals.Add("orderID", orderID)
	
	vals.Add("traceCtx", traceCtx)
	

	encoded_url, err := url.Parse(client.ServerAddress + "/GetOrder")
	if err != nil {
		return
	}
	encoded_url.RawQuery = vals.Encode()

	resp, err := client.Client.Get(encoded_url.String())
	if err != nil {
		return
	}
	defer resp.Body.Close()
	statusOk := resp.StatusCode >= 200 && resp.StatusCode < 300
	if !statusOk {
		err = fmt.Errorf("StatusCode was %d", resp.StatusCode)
		return
	}
	response := struct {
		
		Ret0 order.Order
		
	}{}
	resp_bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return
	}
	err = json.Unmarshal(resp_bytes, &response)
	if err != nil {
		return
	}
	
	ret0 = response.Ret0
	
	return
}

func (client *Frontend_HTTPClient) GetOrders(ctx context.Context, userID string, traceCtx string) (ret0 []order.Order, err error) {
	vals := url.Values{}
	
	vals.Add("userID", userID)
	
	vals.Add("traceCtx", traceCtx)
	

	encoded_url, err := url.Parse(client.ServerAddress + "/GetOrders")
	if err != nil {
		return
	}
	encoded_url.RawQuery = vals.Encode()

	resp, err := client.Client.Get(encoded_url.String())
	if err != nil {
		return
	}
	defer resp.Body.Close()
	statusOk := resp.StatusCode >= 200 && resp.StatusCode < 300
	if !statusOk {
		err = fmt.Errorf("StatusCode was %d", resp.StatusCode)
		return
	}
	response := struct {
		
		Ret0 []order.Order
		
	}{}
	resp_bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return
	}
	err = json.Unmarshal(resp_bytes, &response)
	if err != nil {
		return
	}
	
	ret0 = response.Ret0
	
	return
}

func (client *Frontend_HTTPClient) GetSock(ctx context.Context, itemID string, traceCtx string) (ret0 catalogue.Sock, err error) {
	vals := url.Values{}
	
	vals.Add("itemID", itemID)
	
	vals.Add("traceCtx", traceCtx)
	

	encoded_url, err := url.Parse(client.ServerAddress + "/GetSock")
	if err != nil {
		return
	}
	encoded_url.RawQuery = vals.Encode()

	resp, err := client.Client.Get(encoded_url.String())
	if err != nil {
		return
	}
	defer resp.Body.Close()
	statusOk := resp.StatusCode >= 200 && resp.StatusCode < 300
	if !statusOk {
		err = fmt.Errorf("StatusCode was %d", resp.StatusCode)
		return
	}
	response := struct {
		
		Ret0 catalogue.Sock
		
	}{}
	resp_bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return
	}
	err = json.Unmarshal(resp_bytes, &response)
	if err != nil {
		return
	}
	
	ret0 = response.Ret0
	
	return
}

func (client *Frontend_HTTPClient) GetUser(ctx context.Context, userID string, traceCtx string) (ret0 user.User, err error) {
	vals := url.Values{}
	
	vals.Add("userID", userID)
	
	vals.Add("traceCtx", traceCtx)
	

	encoded_url, err := url.Parse(client.ServerAddress + "/GetUser")
	if err != nil {
		return
	}
	encoded_url.RawQuery = vals.Encode()

	resp, err := client.Client.Get(encoded_url.String())
	if err != nil {
		return
	}
	defer resp.Body.Close()
	statusOk := resp.StatusCode >= 200 && resp.StatusCode < 300
	if !statusOk {
		err = fmt.Errorf("StatusCode was %d", resp.StatusCode)
		return
	}
	response := struct {
		
		Ret0 user.User
		
	}{}
	resp_bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return
	}
	err = json.Unmarshal(resp_bytes, &response)
	if err != nil {
		return
	}
	
	ret0 = response.Ret0
	
	return
}

func (client *Frontend_HTTPClient) ListItems(ctx context.Context, tags []string, order string, pageNum int, pageSize int, traceCtx string) (ret0 []catalogue.Sock, err error) {
	vals := url.Values{}
	
	bytes_tags, err := json.Marshal(tags)
	if err != nil {
		return
	}
	vals.Add("tags", string(bytes_tags))
	
	vals.Add("order", order)
	
	bytes_pageNum, err := json.Marshal(pageNum)
	if err != nil {
		return
	}
	vals.Add("pageNum", string(bytes_pageNum))
	
	bytes_pageSize, err := json.Marshal(pageSize)
	if err != nil {
		return
	}
	vals.Add("pageSize", string(bytes_pageSize))
	
	vals.Add("traceCtx", traceCtx)
	

	encoded_url, err := url.Parse(client.ServerAddress + "/ListItems")
	if err != nil {
		return
	}
	encoded_url.RawQuery = vals.Encode()

	resp, err := client.Client.Get(encoded_url.String())
	if err != nil {
		return
	}
	defer resp.Body.Close()
	statusOk := resp.StatusCode >= 200 && resp.StatusCode < 300
	if !statusOk {
		err = fmt.Errorf("StatusCode was %d", resp.StatusCode)
		return
	}
	response := struct {
		
		Ret0 []catalogue.Sock
		
	}{}
	resp_bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return
	}
	err = json.Unmarshal(resp_bytes, &response)
	if err != nil {
		return
	}
	
	ret0 = response.Ret0
	
	return
}

func (client *Frontend_HTTPClient) ListTags(ctx context.Context, traceCtx string) (ret0 []string, err error) {
	vals := url.Values{}
	
	vals.Add("traceCtx", traceCtx)
	

	encoded_url, err := url.Parse(client.ServerAddress + "/ListTags")
	if err != nil {
		return
	}
	encoded_url.RawQuery = vals.Encode()

	resp, err := client.Client.Get(encoded_url.String())
	if err != nil {
		return
	}
	defer resp.Body.Close()
	statusOk := resp.StatusCode >= 200 && resp.StatusCode < 300
	if !statusOk {
		err = fmt.Errorf("StatusCode was %d", resp.StatusCode)
		return
	}
	response := struct {
		
		Ret0 []string
		
	}{}
	resp_bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return
	}
	err = json.Unmarshal(resp_bytes, &response)
	if err != nil {
		return
	}
	
	ret0 = response.Ret0
	
	return
}

func (client *Frontend_HTTPClient) LoadCatalogue(ctx context.Context, traceCtx string) (ret0 string, err error) {
	vals := url.Values{}
	
	vals.Add("traceCtx", traceCtx)
	

	encoded_url, err := url.Parse(client.ServerAddress + "/LoadCatalogue")
	if err != nil {
		return
	}
	encoded_url.RawQuery = vals.Encode()

	resp, err := client.Client.Get(encoded_url.String())
	if err != nil {
		return
	}
	defer resp.Body.Close()
	statusOk := resp.StatusCode >= 200 && resp.StatusCode < 300
	if !statusOk {
		err = fmt.Errorf("StatusCode was %d", resp.StatusCode)
		return
	}
	response := struct {
		
		Ret0 string
		
	}{}
	resp_bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return
	}
	err = json.Unmarshal(resp_bytes, &response)
	if err != nil {
		return
	}
	
	ret0 = response.Ret0
	
	return
}

func (client *Frontend_HTTPClient) Login(ctx context.Context, sessionID string, username string, password string, traceCtx string) (ret0 string, ret1 user.User, err error) {
	vals := url.Values{}
	
	vals.Add("sessionID", sessionID)
	
	vals.Add("username", username)
	
	vals.Add("password", password)
	
	vals.Add("traceCtx", traceCtx)
	

	encoded_url, err := url.Parse(client.ServerAddress + "/Login")
	if err != nil {
		return
	}
	encoded_url.RawQuery = vals.Encode()

	resp, err := client.Client.Get(encoded_url.String())
	if err != nil {
		return
	}
	defer resp.Body.Close()
	statusOk := resp.StatusCode >= 200 && resp.StatusCode < 300
	if !statusOk {
		err = fmt.Errorf("StatusCode was %d", resp.StatusCode)
		return
	}
	response := struct {
		
		Ret0 string
		
		Ret1 user.User
		
	}{}
	resp_bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return
	}
	err = json.Unmarshal(resp_bytes, &response)
	if err != nil {
		return
	}
	
	ret0 = response.Ret0
	
	ret1 = response.Ret1
	
	return
}

func (client *Frontend_HTTPClient) NewOrder(ctx context.Context, userID string, addressID string, cardID string, cartID string, traceCtx string) (ret0 order.Order, err error) {
	vals := url.Values{}
	
	vals.Add("userID", userID)
	
	vals.Add("addressID", addressID)
	
	vals.Add("cardID", cardID)
	
	vals.Add("cartID", cartID)
	
	vals.Add("traceCtx", traceCtx)
	

	encoded_url, err := url.Parse(client.ServerAddress + "/NewOrder")
	if err != nil {
		return
	}
	encoded_url.RawQuery = vals.Encode()

	resp, err := client.Client.Get(encoded_url.String())
	if err != nil {
		return
	}
	defer resp.Body.Close()
	statusOk := resp.StatusCode >= 200 && resp.StatusCode < 300
	if !statusOk {
		err = fmt.Errorf("StatusCode was %d", resp.StatusCode)
		return
	}
	response := struct {
		
		Ret0 order.Order
		
	}{}
	resp_bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return
	}
	err = json.Unmarshal(resp_bytes, &response)
	if err != nil {
		return
	}
	
	ret0 = response.Ret0
	
	return
}

func (client *Frontend_HTTPClient) PostAddress(ctx context.Context, userID string, address user.Address, traceCtx string) (ret0 string, err error) {
	vals := url.Values{}
	
	vals.Add("userID", userID)
	
	bytes_address, err := json.Marshal(address)
	if err != nil {
		return
	}
	vals.Add("address", string(bytes_address))
	
	vals.Add("traceCtx", traceCtx)
	

	encoded_url, err := url.Parse(client.ServerAddress + "/PostAddress")
	if err != nil {
		return
	}
	encoded_url.RawQuery = vals.Encode()

	resp, err := client.Client.Get(encoded_url.String())
	if err != nil {
		return
	}
	defer resp.Body.Close()
	statusOk := resp.StatusCode >= 200 && resp.StatusCode < 300
	if !statusOk {
		err = fmt.Errorf("StatusCode was %d", resp.StatusCode)
		return
	}
	response := struct {
		
		Ret0 string
		
	}{}
	resp_bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return
	}
	err = json.Unmarshal(resp_bytes, &response)
	if err != nil {
		return
	}
	
	ret0 = response.Ret0
	
	return
}

func (client *Frontend_HTTPClient) PostCard(ctx context.Context, userID string, card user.Card, traceCtx string) (ret0 string, err error) {
	vals := url.Values{}
	
	vals.Add("userID", userID)
	
	bytes_card, err := json.Marshal(card)
	if err != nil {
		return
	}
	vals.Add("card", string(bytes_card))
	
	vals.Add("traceCtx", traceCtx)
	

	encoded_url, err := url.Parse(client.ServerAddress + "/PostCard")
	if err != nil {
		return
	}
	encoded_url.RawQuery = vals.Encode()

	resp, err := client.Client.Get(encoded_url.String())
	if err != nil {
		return
	}
	defer resp.Body.Close()
	statusOk := resp.StatusCode >= 200 && resp.StatusCode < 300
	if !statusOk {
		err = fmt.Errorf("StatusCode was %d", resp.StatusCode)
		return
	}
	response := struct {
		
		Ret0 string
		
	}{}
	resp_bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return
	}
	err = json.Unmarshal(resp_bytes, &response)
	if err != nil {
		return
	}
	
	ret0 = response.Ret0
	
	return
}

func (client *Frontend_HTTPClient) Register(ctx context.Context, sessionID string, username string, password string, email string, first string, last string, traceCtx string) (ret0 string, err error) {
	vals := url.Values{}
	
	vals.Add("sessionID", sessionID)
	
	vals.Add("username", username)
	
	vals.Add("password", password)
	
	vals.Add("email", email)
	
	vals.Add("first", first)
	
	vals.Add("last", last)
	
	vals.Add("traceCtx", traceCtx)
	

	encoded_url, err := url.Parse(client.ServerAddress + "/Register")
	if err != nil {
		return
	}
	encoded_url.RawQuery = vals.Encode()

	resp, err := client.Client.Get(encoded_url.String())
	if err != nil {
		return
	}
	defer resp.Body.Close()
	statusOk := resp.StatusCode >= 200 && resp.StatusCode < 300
	if !statusOk {
		err = fmt.Errorf("StatusCode was %d", resp.StatusCode)
		return
	}
	response := struct {
		
		Ret0 string
		
	}{}
	resp_bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return
	}
	err = json.Unmarshal(resp_bytes, &response)
	if err != nil {
		return
	}
	
	ret0 = response.Ret0
	
	return
}

func (client *Frontend_HTTPClient) RemoveItem(ctx context.Context, sessionID string, itemID string, traceCtx string) (err error) {
	vals := url.Values{}
	
	vals.Add("sessionID", sessionID)
	
	vals.Add("itemID", itemID)
	
	vals.Add("traceCtx", traceCtx)
	

	encoded_url, err := url.Parse(client.ServerAddress + "/RemoveItem")
	if err != nil {
		return
	}
	encoded_url.RawQuery = vals.Encode()

	resp, err := client.Client.Get(encoded_url.String())
	if err != nil {
		return
	}
	defer resp.Body.Close()
	statusOk := resp.StatusCode >= 200 && resp.StatusCode < 300
	if !statusOk {
		err = fmt.Errorf("StatusCode was %d", resp.StatusCode)
		return
	}
	response := struct {
		
	}{}
	resp_bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return
	}
	err = json.Unmarshal(resp_bytes, &response)
	if err != nil {
		return
	}
	
	return
}

func (client *Frontend_HTTPClient) UpdateItem(ctx context.Context, sessionID string, itemID string, quantity int, traceCtx string) (ret0 string, err error) {
	vals := url.Values{}
	
	vals.Add("sessionID", sessionID)
	
	vals.Add("itemID", itemID)
	
	bytes_quantity, err := json.Marshal(quantity)
	if err != nil {
		return
	}
	vals.Add("quantity", string(bytes_quantity))
	
	vals.Add("traceCtx", traceCtx)
	

	encoded_url, err := url.Parse(client.ServerAddress + "/UpdateItem")
	if err != nil {
		return
	}
	encoded_url.RawQuery = vals.Encode()

	resp, err := client.Client.Get(encoded_url.String())
	if err != nil {
		return
	}
	defer resp.Body.Close()
	statusOk := resp.StatusCode >= 200 && resp.StatusCode < 300
	if !statusOk {
		err = fmt.Errorf("StatusCode was %d", resp.StatusCode)
		return
	}
	response := struct {
		
		Ret0 string
		
	}{}
	resp_bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return
	}
	err = json.Unmarshal(resp_bytes, &response)
	if err != nil {
		return
	}
	
	ret0 = response.Ret0
	
	return
}

